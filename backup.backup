


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "postgis" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."get_distinct_country_codes"() RETURNS TABLE("country_code" "text")
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT DISTINCT country_code
  FROM public.geo_areas
  WHERE level = 0
  ORDER BY country_code;
$$;


ALTER FUNCTION "public"."get_distinct_country_codes"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_distinct_country_codes"() IS 'Get all available country codes.';



CREATE OR REPLACE FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") RETURNS TABLE("id" "uuid", "parent_id" "uuid", "level" smallint, "adm_id" "text", "country_code" "text", "name" "text", "name_en" "text", "name_ja" "text", "iso_code" "text", "wikipedia" "text", "thumbnail_url" "text", "center_geojson" "text", "polygons_geojson" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE ancestors AS (
    SELECT ga.id, ga.parent_id, ga.level, ga.adm_id, ga.country_code,
           ga.name, ga.name_en, ga.name_ja, ga.iso_code, ga.wikipedia, ga.thumbnail_url,
           ga.center, ga.polygons, ga.created_at, ga.updated_at
    FROM public.geo_areas ga
    WHERE ga.id = p_area_id

    UNION ALL

    SELECT ga.id, ga.parent_id, ga.level, ga.adm_id, ga.country_code,
           ga.name, ga.name_en, ga.name_ja, ga.iso_code, ga.wikipedia, ga.thumbnail_url,
           ga.center, ga.polygons, ga.created_at, ga.updated_at
    FROM public.geo_areas ga
    JOIN ancestors a ON ga.id = a.parent_id
  )
  SELECT a.id, a.parent_id, a.level, a.adm_id, a.country_code,
         a.name, a.name_en, a.name_ja, a.iso_code, a.wikipedia, a.thumbnail_url,
         ST_AsGeoJSON(a.center::geometry)::TEXT,
         ST_AsGeoJSON(a.polygons)::TEXT,
         a.created_at, a.updated_at
  FROM ancestors a
  ORDER BY a.level;
END;
$$;


ALTER FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") IS 'Get all ancestors of a geo area (path to root).';


SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."geo_areas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "parent_id" "uuid",
    "level" smallint NOT NULL,
    "adm_id" "text" NOT NULL,
    "country_code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "name_en" "text",
    "name_ja" "text",
    "iso_code" "text",
    "wikipedia" "text",
    "thumbnail_url" "text",
    "center" "extensions"."geography"(Point,4326),
    "polygons" "extensions"."geometry"(MultiPolygon,4326) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "geo_areas_level_check" CHECK ((("level" >= 0) AND ("level" <= 5)))
);


ALTER TABLE "public"."geo_areas" OWNER TO "postgres";


COMMENT ON TABLE "public"."geo_areas" IS 'Unified geo areas table supporting ADM0-5 hierarchy with self-referencing parent_id.';



COMMENT ON COLUMN "public"."geo_areas"."id" IS 'Internal primary key (UUID).';



COMMENT ON COLUMN "public"."geo_areas"."parent_id" IS 'Parent area UUID. NULL for ADM0 (country) level.';



COMMENT ON COLUMN "public"."geo_areas"."level" IS 'Administrative level: 0=Country, 1=Prefecture/State, 2=City/District, etc.';



COMMENT ON COLUMN "public"."geo_areas"."adm_id" IS 'Administrative identifier from data source.';



COMMENT ON COLUMN "public"."geo_areas"."country_code" IS 'ISO 3166-1 alpha-2 country code.';



COMMENT ON COLUMN "public"."geo_areas"."name" IS 'Default display name.';



COMMENT ON COLUMN "public"."geo_areas"."name_en" IS 'English name if available.';



COMMENT ON COLUMN "public"."geo_areas"."name_ja" IS 'Japanese name if available.';



COMMENT ON COLUMN "public"."geo_areas"."iso_code" IS 'ISO code (e.g., ISO 3166-2 for ADM1).';



COMMENT ON COLUMN "public"."geo_areas"."wikipedia" IS 'Wikipedia tag/value for fetching thumbnails.';



COMMENT ON COLUMN "public"."geo_areas"."thumbnail_url" IS 'Thumbnail URL or Storage public URL.';



COMMENT ON COLUMN "public"."geo_areas"."center" IS 'Center point (geography, SRID 4326).';



COMMENT ON COLUMN "public"."geo_areas"."polygons" IS 'Boundary polygons (geometry MultiPolygon, SRID 4326).';



COMMENT ON COLUMN "public"."geo_areas"."created_at" IS 'Creation timestamp.';



COMMENT ON COLUMN "public"."geo_areas"."updated_at" IS 'Last updated timestamp.';



CREATE OR REPLACE VIEW "public"."geo_areas_view" WITH ("security_invoker"='true') AS
 SELECT "id",
    "parent_id",
    "level",
    "adm_id",
    "country_code",
    "name",
    "name_en",
    "name_ja",
    "iso_code",
    "wikipedia",
    "thumbnail_url",
    "extensions"."st_asgeojson"(("center")::"extensions"."geometry") AS "center_geojson",
    "extensions"."st_asgeojson"("polygons") AS "polygons_geojson",
    "created_at",
    "updated_at"
   FROM "public"."geo_areas";


ALTER VIEW "public"."geo_areas_view" OWNER TO "postgres";


COMMENT ON VIEW "public"."geo_areas_view" IS 'geo_areas with geometry columns converted to GeoJSON strings for client consumption.';



CREATE OR REPLACE FUNCTION "public"."get_geo_area_children"("p_parent_id" "uuid") RETURNS SETOF "public"."geo_areas_view"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT *
  FROM public.geo_areas_view
  WHERE parent_id = p_parent_id
  ORDER BY name;
$$;


ALTER FUNCTION "public"."get_geo_area_children"("p_parent_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint DEFAULT 10) RETURNS TABLE("id" "uuid", "parent_id" "uuid", "level" smallint, "adm_id" "text", "country_code" "text", "name" "text", "name_en" "text", "name_ja" "text", "iso_code" "text", "wikipedia" "text", "thumbnail_url" "text", "center_geojson" "text", "polygons_geojson" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH RECURSIVE descendants AS (
    SELECT ga.id, ga.parent_id, ga.level, ga.adm_id, ga.country_code,
           ga.name, ga.name_en, ga.name_ja, ga.iso_code, ga.wikipedia, ga.thumbnail_url,
           ga.center, ga.polygons, ga.created_at, ga.updated_at, 0 AS depth
    FROM public.geo_areas ga
    WHERE ga.id = p_area_id

    UNION ALL

    SELECT ga.id, ga.parent_id, ga.level, ga.adm_id, ga.country_code,
           ga.name, ga.name_en, ga.name_ja, ga.iso_code, ga.wikipedia, ga.thumbnail_url,
           ga.center, ga.polygons, ga.created_at, ga.updated_at, d.depth + 1
    FROM public.geo_areas ga
    JOIN descendants d ON ga.parent_id = d.id
    WHERE d.depth < p_max_depth
  )
  SELECT d.id, d.parent_id, d.level, d.adm_id, d.country_code,
         d.name, d.name_en, d.name_ja, d.iso_code, d.wikipedia, d.thumbnail_url,
         ST_AsGeoJSON(d.center::geometry)::TEXT,
         ST_AsGeoJSON(d.polygons)::TEXT,
         d.created_at, d.updated_at
  FROM descendants d
  ORDER BY d.level, d.name;
END;
$$;


ALTER FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint) IS 'Get all descendants of a geo area recursively.';



CREATE OR REPLACE FUNCTION "public"."get_geo_areas_by_country"("p_country_code" "text", "p_max_level" smallint DEFAULT NULL::smallint) RETURNS SETOF "public"."geo_areas_view"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT *
  FROM public.geo_areas_view
  WHERE country_code = p_country_code
    AND (p_max_level IS NULL OR level <= p_max_level)
  ORDER BY level, name;
$$;


ALTER FUNCTION "public"."get_geo_areas_by_country"("p_country_code" "text", "p_max_level" smallint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_geo_areas_by_level"("p_country_code" "text", "p_level" smallint) RETURNS SETOF "public"."geo_areas_view"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT *
  FROM public.geo_areas_view
  WHERE country_code = p_country_code
    AND level = p_level
  ORDER BY name;
$$;


ALTER FUNCTION "public"."get_geo_areas_by_level"("p_country_code" "text", "p_level" smallint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint DEFAULT NULL::smallint) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_total INT;
  v_missing_name_en INT;
  v_missing_name_ja INT;
BEGIN
  IF p_level IS NOT NULL THEN
    SELECT COUNT(*) INTO v_total
    FROM public.geo_areas
    WHERE country_code = p_country_code AND level = p_level;

    SELECT COUNT(*) INTO v_missing_name_en
    FROM public.geo_areas
    WHERE country_code = p_country_code AND level = p_level AND name_en IS NULL;

    SELECT COUNT(*) INTO v_missing_name_ja
    FROM public.geo_areas
    WHERE country_code = p_country_code AND level = p_level AND name_ja IS NULL;
  ELSE
    SELECT COUNT(*) INTO v_total
    FROM public.geo_areas
    WHERE country_code = p_country_code;

    SELECT COUNT(*) INTO v_missing_name_en
    FROM public.geo_areas
    WHERE country_code = p_country_code AND name_en IS NULL;

    SELECT COUNT(*) INTO v_missing_name_ja
    FROM public.geo_areas
    WHERE country_code = p_country_code AND name_ja IS NULL;
  END IF;

  RETURN jsonb_build_object(
    'total', v_total,
    'missing_name_en', v_missing_name_en,
    'missing_name_ja', v_missing_name_ja
  );
END;
$$;


ALTER FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint) IS 'Get count of areas with missing name_en or name_ja for a country, optionally filtered by level.';



CREATE OR REPLACE FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_update JSONB;
  v_id UUID;
  v_name_en TEXT;
  v_name_ja TEXT;
BEGIN
  FOR v_update IN SELECT * FROM jsonb_array_elements(p_updates)
  LOOP
    v_id := (v_update->>'id')::UUID;
    v_name_en := v_update->>'name_en';
    v_name_ja := v_update->>'name_ja';

    UPDATE public.geo_areas
    SET
      name_en = COALESCE(v_name_en, name_en),
      name_ja = COALESCE(v_name_ja, name_ja),
      updated_at = NOW()
    WHERE id = v_id;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") IS 'Batch update name_en and name_ja for geo_areas. Only updates non-null values.';



CREATE OR REPLACE FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text" DEFAULT NULL::"text", "p_name_ja" "text" DEFAULT NULL::"text", "p_iso_code" "text" DEFAULT NULL::"text", "p_wikipedia" "text" DEFAULT NULL::"text", "p_thumbnail_url" "text" DEFAULT NULL::"text", "p_center_lat" double precision DEFAULT NULL::double precision, "p_center_lon" double precision DEFAULT NULL::double precision, "p_polygons_geojson" "jsonb" DEFAULT NULL::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_area_id UUID;
  v_center GEOGRAPHY(POINT, 4326);
  v_polygons GEOMETRY(MULTIPOLYGON, 4326);
BEGIN
  -- Build center point if coordinates provided
  IF p_center_lat IS NOT NULL AND p_center_lon IS NOT NULL THEN
    v_center := ST_SetSRID(ST_MakePoint(p_center_lon, p_center_lat), 4326)::GEOGRAPHY;
  END IF;

  -- Build polygons from GeoJSON
  IF p_polygons_geojson IS NOT NULL THEN
    v_polygons := ST_SetSRID(ST_GeomFromGeoJSON(p_polygons_geojson::TEXT), 4326);
  END IF;

  -- Upsert based on (parent_id, adm_id)
  INSERT INTO public.geo_areas (
    parent_id, level, adm_id, country_code,
    name, name_en, name_ja,
    iso_code, wikipedia, thumbnail_url,
    center, polygons
  )
  VALUES (
    p_parent_id, p_level, p_adm_id, p_country_code,
    p_name, p_name_en, p_name_ja,
    p_iso_code, p_wikipedia, p_thumbnail_url,
    v_center, v_polygons
  )
  ON CONFLICT (parent_id, adm_id)
  DO UPDATE SET
    level = EXCLUDED.level,
    country_code = EXCLUDED.country_code,
    name = EXCLUDED.name,
    name_en = EXCLUDED.name_en,
    name_ja = EXCLUDED.name_ja,
    iso_code = EXCLUDED.iso_code,
    wikipedia = EXCLUDED.wikipedia,
    thumbnail_url = EXCLUDED.thumbnail_url,
    center = EXCLUDED.center,
    polygons = EXCLUDED.polygons,
    updated_at = NOW()
  RETURNING id INTO v_area_id;

  RETURN v_area_id;
END;
$$;


ALTER FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text", "p_name_ja" "text", "p_iso_code" "text", "p_wikipedia" "text", "p_thumbnail_url" "text", "p_center_lat" double precision, "p_center_lon" double precision, "p_polygons_geojson" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text", "p_name_ja" "text", "p_iso_code" "text", "p_wikipedia" "text", "p_thumbnail_url" "text", "p_center_lat" double precision, "p_center_lon" double precision, "p_polygons_geojson" "jsonb") IS 'Upsert a single geo_area. Returns the area UUID.';



CREATE OR REPLACE FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'extensions'
    AS $$
DECLARE
  v_area RECORD;
  v_result JSONB := '[]'::JSONB;
  v_area_id UUID;
  v_center GEOGRAPHY(POINT, 4326);
  v_polygons GEOMETRY(MULTIPOLYGON, 4326);
BEGIN
  -- Process each area in the batch
  FOR v_area IN
    SELECT
      (a->>'parent_id')::UUID AS parent_id,
      (a->>'level')::SMALLINT AS level,
      a->>'adm_id' AS adm_id,
      a->>'country_code' AS country_code,
      a->>'name' AS name,
      a->>'name_en' AS name_en,
      a->>'name_ja' AS name_ja,
      a->>'iso_code' AS iso_code,
      a->>'wikipedia' AS wikipedia,
      a->>'thumbnail_url' AS thumbnail_url,
      (a->>'center_lat')::DOUBLE PRECISION AS center_lat,
      (a->>'center_lon')::DOUBLE PRECISION AS center_lon,
      a->'polygons_geojson' AS polygons_geojson
    FROM jsonb_array_elements(p_areas) AS a
  LOOP
    -- Build center point
    v_center := NULL;
    IF v_area.center_lat IS NOT NULL AND v_area.center_lon IS NOT NULL THEN
      v_center := ST_SetSRID(ST_MakePoint(v_area.center_lon, v_area.center_lat), 4326)::GEOGRAPHY;
    END IF;

    -- Build polygons
    v_polygons := NULL;
    IF v_area.polygons_geojson IS NOT NULL THEN
      v_polygons := ST_SetSRID(ST_GeomFromGeoJSON(v_area.polygons_geojson::TEXT), 4326);
    END IF;

    -- Upsert
    INSERT INTO public.geo_areas (
      parent_id, level, adm_id, country_code,
      name, name_en, name_ja,
      iso_code, wikipedia, thumbnail_url,
      center, polygons
    )
    VALUES (
      v_area.parent_id, v_area.level, v_area.adm_id, v_area.country_code,
      v_area.name, v_area.name_en, v_area.name_ja,
      v_area.iso_code, v_area.wikipedia, v_area.thumbnail_url,
      v_center, v_polygons
    )
    ON CONFLICT (parent_id, adm_id)
    DO UPDATE SET
      level = EXCLUDED.level,
      country_code = EXCLUDED.country_code,
      name = EXCLUDED.name,
      name_en = EXCLUDED.name_en,
      name_ja = EXCLUDED.name_ja,
      iso_code = EXCLUDED.iso_code,
      wikipedia = EXCLUDED.wikipedia,
      thumbnail_url = EXCLUDED.thumbnail_url,
      center = EXCLUDED.center,
      polygons = EXCLUDED.polygons,
      updated_at = NOW()
    RETURNING id INTO v_area_id;

    -- Append result
    v_result := v_result || jsonb_build_object(
      'adm_id', v_area.adm_id,
      'id', v_area_id
    );
  END LOOP;

  RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") IS 'Batch upsert geo_areas. Returns array of {adm_id, id} mappings.';



CREATE TABLE IF NOT EXISTS "public"."image_comments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "image_id" "uuid" NOT NULL,
    "author_user_id" "uuid" NOT NULL,
    "body" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone,
    "deleted_at" timestamp with time zone
);


ALTER TABLE "public"."image_comments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."images" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "uploader_user_id" "uuid" NOT NULL,
    "map_region_id" "uuid",
    "storage_key" "text" NOT NULL,
    "content_type" "text",
    "file_size" bigint,
    "width" integer,
    "height" integer,
    "taken_at" timestamp with time zone,
    "taken_lat" double precision,
    "taken_lng" double precision,
    "exif" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."images" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."map_regions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "map_id" "uuid" NOT NULL,
    "geo_area_id" "uuid" NOT NULL,
    "representative_image_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."map_regions" OWNER TO "postgres";


COMMENT ON TABLE "public"."map_regions" IS 'Selected regions within a map, referencing geo_areas.';



COMMENT ON COLUMN "public"."map_regions"."id" IS 'Primary key UUID.';



COMMENT ON COLUMN "public"."map_regions"."map_id" IS 'Parent map UUID.';



COMMENT ON COLUMN "public"."map_regions"."geo_area_id" IS 'Referenced geo_area UUID.';



COMMENT ON COLUMN "public"."map_regions"."representative_image_id" IS 'Optional representative image UUID.';



CREATE TABLE IF NOT EXISTS "public"."maps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "owner_user_id" "uuid" NOT NULL,
    "root_geo_area_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "icon_image_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."maps" OWNER TO "postgres";


COMMENT ON TABLE "public"."maps" IS 'User-created map collections with geographical scope.';



COMMENT ON COLUMN "public"."maps"."id" IS 'Primary key UUID.';



COMMENT ON COLUMN "public"."maps"."owner_user_id" IS 'Owner user UUID.';



COMMENT ON COLUMN "public"."maps"."root_geo_area_id" IS 'Root geo_area UUID (country or region scope).';



COMMENT ON COLUMN "public"."maps"."title" IS 'Map title.';



COMMENT ON COLUMN "public"."maps"."description" IS 'Optional map description.';



COMMENT ON COLUMN "public"."maps"."icon_image_id" IS 'Optional icon image UUID.';



CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" NOT NULL,
    "handle" "text" NOT NULL,
    "display_name" "text" NOT NULL,
    "icon_image_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."users" OWNER TO "postgres";


ALTER TABLE ONLY "public"."geo_areas"
    ADD CONSTRAINT "geo_areas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."geo_areas"
    ADD CONSTRAINT "geo_areas_unique_parent_adm" UNIQUE NULLS NOT DISTINCT ("parent_id", "adm_id");



ALTER TABLE ONLY "public"."image_comments"
    ADD CONSTRAINT "image_comments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."map_regions"
    ADD CONSTRAINT "map_regions_map_id_geo_area_id_key" UNIQUE ("map_id", "geo_area_id");



ALTER TABLE ONLY "public"."map_regions"
    ADD CONSTRAINT "map_regions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."maps"
    ADD CONSTRAINT "maps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_handle_key" UNIQUE ("handle");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_geo_areas_center_gist" ON "public"."geo_areas" USING "gist" ("center");



CREATE INDEX "idx_geo_areas_country_code" ON "public"."geo_areas" USING "btree" ("country_code");



CREATE INDEX "idx_geo_areas_country_level" ON "public"."geo_areas" USING "btree" ("country_code", "level");



CREATE INDEX "idx_geo_areas_level" ON "public"."geo_areas" USING "btree" ("level");



CREATE INDEX "idx_geo_areas_parent_id" ON "public"."geo_areas" USING "btree" ("parent_id");



CREATE INDEX "idx_geo_areas_polygons_gist" ON "public"."geo_areas" USING "gist" ("polygons");



CREATE INDEX "idx_image_comments_author_user_id" ON "public"."image_comments" USING "btree" ("author_user_id");



CREATE INDEX "idx_image_comments_image_id" ON "public"."image_comments" USING "btree" ("image_id");



CREATE INDEX "idx_images_map_region_id" ON "public"."images" USING "btree" ("map_region_id");



CREATE INDEX "idx_images_uploader_user_id" ON "public"."images" USING "btree" ("uploader_user_id");



CREATE INDEX "idx_map_regions_geo_area_id" ON "public"."map_regions" USING "btree" ("geo_area_id");



CREATE INDEX "idx_map_regions_map_id" ON "public"."map_regions" USING "btree" ("map_id");



CREATE INDEX "idx_maps_owner_user_id" ON "public"."maps" USING "btree" ("owner_user_id");



CREATE INDEX "idx_maps_root_geo_area_id" ON "public"."maps" USING "btree" ("root_geo_area_id");



ALTER TABLE ONLY "public"."geo_areas"
    ADD CONSTRAINT "geo_areas_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."geo_areas"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."image_comments"
    ADD CONSTRAINT "image_comments_author_user_id_fkey" FOREIGN KEY ("author_user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."image_comments"
    ADD CONSTRAINT "image_comments_image_id_fkey" FOREIGN KEY ("image_id") REFERENCES "public"."images"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_map_region_id_fkey" FOREIGN KEY ("map_region_id") REFERENCES "public"."map_regions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_uploader_user_id_fkey" FOREIGN KEY ("uploader_user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."map_regions"
    ADD CONSTRAINT "map_regions_geo_area_id_fkey" FOREIGN KEY ("geo_area_id") REFERENCES "public"."geo_areas"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."map_regions"
    ADD CONSTRAINT "map_regions_map_id_fkey" FOREIGN KEY ("map_id") REFERENCES "public"."maps"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."maps"
    ADD CONSTRAINT "maps_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."maps"
    ADD CONSTRAINT "maps_root_geo_area_id_fkey" FOREIGN KEY ("root_geo_area_id") REFERENCES "public"."geo_areas"("id") ON DELETE RESTRICT;



ALTER TABLE "public"."geo_areas" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "geo_areas_select_public" ON "public"."geo_areas" FOR SELECT TO "authenticated", "anon" USING (true);



ALTER TABLE "public"."image_comments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "image_comments_author_all" ON "public"."image_comments" USING (("author_user_id" = "auth"."uid"())) WITH CHECK (("author_user_id" = "auth"."uid"()));



ALTER TABLE "public"."images" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "images_uploader_all" ON "public"."images" USING (("uploader_user_id" = "auth"."uid"())) WITH CHECK (("uploader_user_id" = "auth"."uid"()));



ALTER TABLE "public"."map_regions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "map_regions_owner_all" ON "public"."map_regions" USING ((EXISTS ( SELECT 1
   FROM "public"."maps"
  WHERE (("maps"."id" = "map_regions"."map_id") AND ("maps"."owner_user_id" = "auth"."uid"()))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."maps"
  WHERE (("maps"."id" = "map_regions"."map_id") AND ("maps"."owner_user_id" = "auth"."uid"())))));



ALTER TABLE "public"."maps" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "maps_owner_all" ON "public"."maps" USING (("owner_user_id" = "auth"."uid"())) WITH CHECK (("owner_user_id" = "auth"."uid"()));



ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "users_insert_own" ON "public"."users" FOR INSERT WITH CHECK (("id" = "auth"."uid"()));



CREATE POLICY "users_select_own" ON "public"."users" FOR SELECT USING (("id" = "auth"."uid"()));



CREATE POLICY "users_update_own" ON "public"."users" FOR UPDATE USING (("id" = "auth"."uid"())) WITH CHECK (("id" = "auth"."uid"()));





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































GRANT ALL ON FUNCTION "public"."get_distinct_country_codes"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_distinct_country_codes"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_distinct_country_codes"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_geo_area_ancestors"("p_area_id" "uuid") TO "service_role";



GRANT ALL ON TABLE "public"."geo_areas" TO "anon";
GRANT ALL ON TABLE "public"."geo_areas" TO "authenticated";
GRANT ALL ON TABLE "public"."geo_areas" TO "service_role";



GRANT ALL ON TABLE "public"."geo_areas_view" TO "anon";
GRANT ALL ON TABLE "public"."geo_areas_view" TO "authenticated";
GRANT ALL ON TABLE "public"."geo_areas_view" TO "service_role";



GRANT ALL ON FUNCTION "public"."get_geo_area_children"("p_parent_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_geo_area_children"("p_parent_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_geo_area_children"("p_parent_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint) TO "anon";
GRANT ALL ON FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_geo_area_descendants"("p_area_id" "uuid", "p_max_depth" smallint) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_geo_areas_by_country"("p_country_code" "text", "p_max_level" smallint) TO "anon";
GRANT ALL ON FUNCTION "public"."get_geo_areas_by_country"("p_country_code" "text", "p_max_level" smallint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_geo_areas_by_country"("p_country_code" "text", "p_max_level" smallint) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_geo_areas_by_level"("p_country_code" "text", "p_level" smallint) TO "anon";
GRANT ALL ON FUNCTION "public"."get_geo_areas_by_level"("p_country_code" "text", "p_level" smallint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_geo_areas_by_level"("p_country_code" "text", "p_level" smallint) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint) TO "anon";
GRANT ALL ON FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_missing_names_count"("p_country_code" "text", "p_level" smallint) TO "service_role";



GRANT ALL ON FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_geo_area_names_batch"("p_updates" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text", "p_name_ja" "text", "p_iso_code" "text", "p_wikipedia" "text", "p_thumbnail_url" "text", "p_center_lat" double precision, "p_center_lon" double precision, "p_polygons_geojson" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text", "p_name_ja" "text", "p_iso_code" "text", "p_wikipedia" "text", "p_thumbnail_url" "text", "p_center_lat" double precision, "p_center_lon" double precision, "p_polygons_geojson" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_geo_area"("p_parent_id" "uuid", "p_level" smallint, "p_adm_id" "text", "p_country_code" "text", "p_name" "text", "p_name_en" "text", "p_name_ja" "text", "p_iso_code" "text", "p_wikipedia" "text", "p_thumbnail_url" "text", "p_center_lat" double precision, "p_center_lon" double precision, "p_polygons_geojson" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."upsert_geo_areas_batch"("p_areas" "jsonb") TO "service_role";

















































































GRANT ALL ON TABLE "public"."image_comments" TO "anon";
GRANT ALL ON TABLE "public"."image_comments" TO "authenticated";
GRANT ALL ON TABLE "public"."image_comments" TO "service_role";



GRANT ALL ON TABLE "public"."images" TO "anon";
GRANT ALL ON TABLE "public"."images" TO "authenticated";
GRANT ALL ON TABLE "public"."images" TO "service_role";



GRANT ALL ON TABLE "public"."map_regions" TO "anon";
GRANT ALL ON TABLE "public"."map_regions" TO "authenticated";
GRANT ALL ON TABLE "public"."map_regions" TO "service_role";



GRANT ALL ON TABLE "public"."maps" TO "anon";
GRANT ALL ON TABLE "public"."maps" TO "authenticated";
GRANT ALL ON TABLE "public"."maps" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































RESET ALL;
